### Most used Java methods
- `System.out.println()` - prints the output on the console and adds a new line at the end.
- `System.out.print()` - prints the output on the console and doesn't add a new line at the end.
- `<array>.length` - returns the length of the array.
- `<str>.length()` - returns the length of the string.
- `<array>.add(ele)` - adds an element to the array.
- `<array>.remove(ele)` - removes an element from the array.
- `<array>.get(index)` - returns the element at the specified index.
- `<array>.set(index, ele)` - sets the element at the specified index.
- `<array>.clear()` - removes all the elements from the array.
- `<array>.isEmpty()` - returns true if the array is empty else returns false.
- `<array>.contains(ele)` - returns true if the array contains the specified element else returns false.
- `<array>.indexOf(ele)` - returns the index of the specified element in the array.
- `<array>.lastIndexOf(ele)` - returns the last index of the specified element in the array.
- `<array>.toArray()` - converts the array to an array of objects.
- `<array>.toString()` - converts the array to a string.
- `<array>.clone()` - returns a copy of the array.
- `<array>.sort()` - sorts the array in ascending order.
- `<array>.binarySearch()` - searches for an element in the array and returns the index of the element if found else returns a negative value.
> ArrayList also has all the above methods of array. So can say <arraylist>.add() and so on.
- For printing arraylist to the screen no need to call toString() method. Just use `System.out.println(<arraylist>)`.
- `<hashmap>.put(key, value)` - adds a key-value pair to the hashmap.
- `<hashmap>.get(key)` - returns the value of the specified key.
- `<hashmap>.remove(key)` - removes the key-value pair from the hashmap.
- `<hashmap>.containsKey(key)` - returns true if the hashmap contains the specified key else returns false.
- `<hashmap>.containsValue(value)` - returns true if the hashmap contains the specified value else returns false.
- `<hashmap>.keySet()` - returns a set of all the keys in the hashmap.
- `<hashmap>.values()` - returns a collection of all the values in the hashmap.
- `<hashmap>.entrySet()` - returns a set of all the key-value pairs in the hashmap.
- `for(Map.Entry m: <hashmap>.entrySet())` - for iterating over the hashmap.
- `<hashmap_entry>.getKey()` - returns the key of the specified key-value pair.
- `<hashmap_entry>.getValue()` - returns the value of the specified key-value pair.
- `<hashmap>.clear()` - removes all the key-value pairs from the hashmap.
- `<hashmap>.isEmpty()` - returns true if the hashmap is empty else returns false.
- `<hashmap>.size()` - returns the number of key-value pairs in the hashmap.
- `<hashmap>.replace(key, value)` - replaces the value of the specified key with the specified value.
> Stack<Integer> stack = new Stack<>();  //Example stack of Integer datatype.
> Queue<Character> queue = new LinkedListQueue<Character>(); //Example queue of Character datatype.
- `<stack>.push(ele)` - adds an element to the stack.
- `<stack>.pop()` - removes the top element from the stack.
- `<stack>.peek()` - returns the top element from the stack.
- `<stack>.empty()` - returns true if the stack is empty else returns false.
- `<stack>.search(ele)` - returns the position of the specified element in the stack.
- `<queue_name>.enqueue()` - adds an element to the queue.
- `<queue_name>.dequeue()` - removes the front element from the queue.
- `<queue_name>.peek()` - returns the front element from the queue.
- `<queue_name>.isEmpty()` - returns true if the queue is empty else returns false.
- `<queue_name>.isFull()` - returns true if the queue is full else returns false.
- `<queue_name>.size()` - returns the number of elements in the queue.
- `<queue_name>.first()` - returns the first element from the queue.
- `<queue_name>.last()` - returns the last element from the queue.
- `<queue_name>.contains(ele)` - returns true if the queue contains the specified element else returns false.
- `Arrays.toString()` - prints the array in a readable format.
- `Arrays.sort()` - sorts the array in ascending order.
- `Arrays.binarySearch()` - searches for an element in the array and returns the index of the element if found else returns a negative value.

### Most used Java Packages/Classes
- `Scanner` class from `java.util` package
- `Arrays` class from `java.util` package
- `ArrayList` class from `java.util` package
- `HashMap` class from `java.util` package
- `Stack` class from `java.util` package
- `Queue` class from `java.util` package 
> Just import java.util.* to import all the classes from the package.
- `Math` class from `java.lang` package (default)
- `String` class from `java.lang` package (default)
- `Integer` class from `java.lang` package (default)

### Notes on Java
- Java is a procedural as well as an object-oriented language.
- It's a statically typed language.
![Java Intro.png](..%2F..%2F..%2FDownloads%2FJava%20Intro.png)
- Every file name ending with extension ".java" is a class itself.
- Class names should start with capital letters. Though you can also start with small letters, it's not considered a good practice.
- each line has to end with a semi-colon
- The public class name should be the same name as the file name.
- java. lang packages are by default imported in the java class by the JVM
- One can use wrapper classes like Integer instead of primitive datatypes like int to add more functionality to the variables.
- Java supports unicode values meaning that it can support any language in the world.
- "==" is used to compare the values of two variables. It is used to compare the reference of two objects. To compare the values of two objects, we use the `equals()` method. Like `str1.equals(str2)`.
- Any function inside a static function also has to be static. Basically, a static function can only call other static functions. And even variables inside a static function have to be static. Else create an object of the class and call the function using that object.
- Primitive datatypes are stored in the stack while objects are stored in the heap.
- Primitive datatypes are passed by value while objects are passed by reference.
- References in Java abstract memory management, providing safety and simplicity by preventing common memory-related issues.
- Java abstracts away memory management. You create objects using the new keyword, and Java's garbage collector automatically reclaims memory when objects are no longer reachable.
- A reference points to an object in memory, but you don't directly manipulate memory addresses like in C.
- Shadowing is when a variable in a local scope has the same name as a variable in an outer scope. The local variable shadows the outer variable.
- Variable Arguments (varargs) are a feature that allows you to pass an arbitrary number of arguments to a method. Denoted by three dots (...), varargs are used when you don't know how many arguments will be passed to a method, or if you don't want to create a separate parameter for each argument.
- varargs should be the last parameter in a method's parameter list.
- array objects are in heap and heap objects are not continuous in memory. So array objects may not be continuous in memory.
- Reference variables are created at compile time but the objects are created at runtime i.e. dynamic memory allocation(DMA).
- "null" can be only assigned to reference variables and not primitive variables.
- Math class is available in java.lang package that means it's available by default.
- int[] arr can be also written as int arr[]. But the first one is preferred.
- Constructors are used to initialize the instance variables of a class. They are written as `<class_name_as_return_type>() {}`.
- final keyword is used to make a variable constant. It can't be changed once initialized.
- if an object is declared final then it can't be changed once initialized. Meaning the values of its properties can be changed but the object itself can't be changed. Can't be reassigned.
- if a method is declared final then it can't be overridden in the child class.
- file with same name can be used in different packages.
- static variables and methods in class are independent of objects. They can be accessed using class name.
- static blocks are executed to initialize static variables. They are executed when the class is loaded for the first time.
- static variables are resolved during compile time since they are not dependent on objects.
- If we want to create an instance of an inner class we have to declare it static or create an instance of the outer class first to access the inner class.
- files in same package can access each other without importing.
- 